<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
<title>Puzzle of Us ‚Äî Mobile Friendly Torn Paper Style</title>
<style>
  * {
    box-sizing: border-box;
    touch-action: none; /* prevent scrolling while dragging */
  }

  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(180deg, #fdf8f3 0%, #f2e9de 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    overflow-x: hidden;
  }

  h1 {
    text-align: center;
    margin: 20px 12px;
    color: #333;
    font-size: clamp(1.2rem, 2vw, 1.8rem);
  }

  #board {
    position: relative;
    width: 90vw;
    max-width: 480px;
    aspect-ratio: 1/1;
    background: #fff;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    touch-action: none;
  }

  .piece {
    position: absolute;
    cursor: grab;
    border-radius: 6px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    transition: transform .12s ease;
    will-change: transform,left,top;
    background-clip: content-box;
    border: 2px solid rgba(255,255,255,0.6);
    clip-path: polygon(5% 0%, 95% 0%, 100% 5%, 100% 95%, 95% 100%, 5% 100%, 0% 95%, 0% 5%);
    touch-action: none;
  }

  .piece.dragging {
    cursor: grabbing;
    transform: scale(1.05);
    z-index: 999;
  }

  .piece.correct {
    box-shadow: 0 6px 30px rgba(0,0,0,0.05);
  }

  .overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.4);
    z-index: 4000;
    opacity: 0;
    pointer-events: none;
    transition: opacity .3s ease;
  }

  .overlay.show {
    opacity: 1;
    pointer-events: all;
  }

  .congrats {
    background: #fff;
    padding: 28px;
    border-radius: 16px;
    max-width: 90%;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
  }

  .congrats h2 {
    margin: 0 0 10px;
    color: #222;
    font-size: 1.4rem;
  }

  .congrats p {
    color: #555;
    margin-bottom: 18px;
    font-size: 1rem;
  }

  .fcc-btn {
    display: inline-block;
    background: #f59e0b;
    color: #fff;
    padding: 12px 20px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 600;
    transition: background 0.25s;
  }

  .fcc-btn:hover {
    background: #d97706;
  }

  @media (max-width: 480px) {
    .congrats h2 {
      font-size: 1.2rem;
    }
    .congrats p {
      font-size: 0.95rem;
    }
    .fcc-btn {
      padding: 10px 16px;
    }
  }
</style>
</head>
<body>

<h1>üß© Solve the puzzle to reveal the message üß°</h1>
<div id="board"></div>

<div id="overlay" class="overlay">
  <div class="congrats">
    <h2>Congratulations!</h2>
    <p id="finalMessage">Happy Anniversary ‚Äî To many more memories together ‚ù§Ô∏è</p>
    <a target="_blank" class="fcc-btn" href="vid.html">CLICK NEXT</a>
  </div>
</div>

<script>
const board = document.getElementById('board');
const overlay = document.getElementById('overlay');
const finalMessage = document.getElementById('finalMessage');

const IMG_SRC = '1.jpg'; // your image file
const grid = 3;
let pieceSize;
let solved = false;

function createPieces() {
  board.innerHTML = '';
  solved = false;
  const size = board.clientWidth;
  pieceSize = size / grid;

  const positions = [];
  for (let r = 0; r < grid; r++) {
    for (let c = 0; c < grid; c++) {
      positions.push({ r, c, index: r * grid + c });
    }
  }

  positions.forEach(pos => {
    const el = document.createElement('div');
    el.className = 'piece';
    el.style.width = pieceSize + 'px';
    el.style.height = pieceSize + 'px';
    el.dataset.correctIndex = pos.index;
    el.style.backgroundImage = `url('${IMG_SRC}')`;
    el.style.backgroundSize = `${grid * 100}% ${grid * 100}%`;
    el.style.backgroundPosition = `${(pos.c / (grid - 1)) * 100}% ${(pos.r / (grid - 1)) * 100}%`;
    el.style.left = Math.random() * (board.clientWidth - pieceSize) + 'px';
    el.style.top = Math.random() * (board.clientHeight - pieceSize) + 'px';
    el.dataset.currentIndex = -1;
    board.appendChild(el);
    setupDrag(el);
  });
}

// Improved touch-friendly drag logic
function setupDrag(el) {
  let offsetX = 0, offsetY = 0, dragging = false;

  el.addEventListener('pointerdown', e => {
    e.preventDefault();
    dragging = true;
    el.setPointerCapture(e.pointerId);
    el.classList.add('dragging');
    const rect = el.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    el.style.zIndex = 1000;
  });

  el.addEventListener('pointermove', e => {
    if (!dragging) return;
    const boardRect = board.getBoundingClientRect();
    const px = e.clientX - offsetX - boardRect.left;
    const py = e.clientY - offsetY - boardRect.top;
    el.style.left = Math.max(0, Math.min(board.clientWidth - pieceSize, px)) + 'px';
    el.style.top = Math.max(0, Math.min(board.clientHeight - pieceSize, py)) + 'px';
  });

  el.addEventListener('pointerup', e => {
    if (!dragging) return;
    dragging = false;
    el.classList.remove('dragging');
    try { el.releasePointerCapture(e.pointerId); } catch {}
    snapPiece(el);
    checkSolved();
  });
}

function snapPiece(el) {
  const left = parseFloat(el.style.left || 0);
  const top = parseFloat(el.style.top || 0);
  const col = Math.round(left / pieceSize);
  const row = Math.round(top / pieceSize);
  const cellX = col * pieceSize;
  const cellY = row * pieceSize;
  const dx = left - cellX, dy = top - cellY;
  const dist = Math.hypot(dx, dy);
  const SNAP = pieceSize * 0.35;

  if (dist <= SNAP) {
    el.style.left = cellX + 'px';
    el.style.top = cellY + 'px';
    el.dataset.currentIndex = row * grid + col;
    if (parseInt(el.dataset.currentIndex) === parseInt(el.dataset.correctIndex)) {
      el.classList.add('correct');
    } else {
      el.classList.remove('correct');
    }
  } else {
    el.dataset.currentIndex = -1;
    el.classList.remove('correct');
  }
}

function checkSolved() {
  const pieces = Array.from(document.querySelectorAll('.piece'));
  const allCorrect = pieces.every(p => parseInt(p.dataset.currentIndex) === parseInt(p.dataset.correctIndex));
  if (allCorrect && !solved) {
    solved = true;
    overlay.classList.add('show');
  }
}

// Recreate puzzle on window resize for responsiveness
window.addEventListener('resize', () => {
  setTimeout(createPieces, 300);
});

window.addEventListener('load', createPieces);
</script>

</body>
</html>
